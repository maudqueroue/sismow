---
title: "flat_minimal.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

# My function

```{r function-create_density_map}


#' Create a map with the desired density of individuals
#'
#' @param shape_obj sf object. The shape of the study site.
#' @param N Numeric. The number of individuals desired in the area.
#' @param grid_size Numeric. Grid size in m.
#' @param density_type Character. 'uniform", 'gradient', 'random', 'covariate'.
#' @param gradient_direction Character. Only for "gradient" `density_type`. Where the highest density comes from. 'N','NE','E'...
#' @param wavelength Numeric. Only for "gradient" and "random" `density_type`. Wavelength of the hotspots of density created. Maximum wavelength for "random" `density_type`. 
#' @param amplitude Numeric. Only for "gradient" and "random" `density_type`. Amplitude of the hotspots of density created. Maximum amplitude for "random" `density_type`. 
#' @param nb_hotspots Numeric. Only for "random" `density_type`. Number of random hotspots to be created.
#'
#' @importFrom sf st_area st_sfc st_contains as_Spatial st_point st_sf st_transform
#' @importFrom sp bbox
#' @importFrom dssd make.region
#' @importFrom dsims make.density add.hotspot
#' @importFrom dplyr mutate filter select
#' @importFrom units drop_units
#' @importFrom stats runif
#' @importFrom assertthat assert_that
#'
#' @return sf object. The map with the densities type choosen and corresponding to the number of individuals desired in the study area. 
#' @export

create_density_map <- function(shape_obj, N, grid_size, density_type, gradient_direction, wavelength, amplitude, nb_hotspots) {
  
  shape_obj <- shape_obj %>%
    st_transform(crs = 2154)
  
  xlim <- bbox(as_Spatial(shape_obj))[1, ]
  ylim <- bbox(as_Spatial(shape_obj))[2, ]
  
  
  region_obj <- make.region(region.name = "Study site",
                            shape = shape_obj,
                            units = "m")
  
  if(density_type == "uniform"){ 
    
    density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
    
  }
  
  
  if(density_type == "gradient"){
    
    if(gradient_direction == "N") {          
      x <- mean(xlim)  
      y <- max(ylim) + (max(ylim) - min(ylim))
    }
    if(gradient_direction == "NE") {
      x <- max(xlim)  
      y <- max(ylim)
    }
    
    if(gradient_direction == "E"){
      x <- max(xlim) + (max(xlim) - min(xlim))  
      y <- mean(ylim)
    }
    
    if(gradient_direction == "SE"){
      x <- max(xlim) 
      y <- min(ylim)
    }
    
    if(gradient_direction == "S") {
      x <- mean(xlim)  
      y <- min(ylim) - (max(ylim) - min(ylim)) 
    }
    
    if(gradient_direction == "SW"){
      x <- min(xlim)  
      y <- min(ylim)
    }
    
    if(gradient_direction == "W"){
      x <- min(xlim) - (max(xlim) - min(xlim))  
      y <- mean(ylim) 
    }
    
    if(gradient_direction == "NW"){
      x <- min(xlim)
      y <- max(ylim)
    }
    
    density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
    
    density_obj <- add.hotspot(object = density_obj,
                               centre = c(x, y),
                               sigma = wavelength,
                               amplitude = amplitude)
    
  }
  

    if(density_type == "random"){
      
          density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
          
          for(i in 1:nb_hotspots){
            
            sigma_n <- runif(1, 1, wavelength)
            amplitude_n <- runif(1, 1, amplitude)
            
            x <- runif(1, xlim[1], xlim[2])
            y <- runif(1, ylim[1], ylim[2])
            
            point <- st_sfc(st_point(c(x,y)), crs = 2154)
            a <- as.numeric(st_contains(shape_obj, point))
            
            while(is.na(a==1)){
              
              x <- runif(1, xlim[1], xlim[2])
              y <- runif(1, ylim[1], ylim[2])
              
              point <- st_sfc(st_point(c(x,y)), crs = 2154)
              
              a <- as.numeric(st_contains(shape_obj, point))
            }
            
            density_obj <- add.hotspot(object = density_obj,
                                       centre = c(x, y),
                                       sigma = sigma_n,
                                       amplitude = amplitude_n)
            
            rm(a, x, y, sigma_n, amplitude_n)
            
          }
    }
      

    
  if(density_type == "covariate") {
    
    density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
  }
  
  
  map_obj <- density_obj@density.surface %>%
    as.data.frame() %>%
    st_sf(crs = 2154) %>%
    mutate(area = st_area(.)) %>%
    mutate(area_grid = grid_size^2) %>%
    drop_units() %>%
    filter(area == area_grid)
  
  total_area <- sum(map_obj$area)
  average_density <- N / total_area

  map_obj <- map_obj %>%
    mutate(density = average_density * density / mean(density, na.rm = TRUE)) %>%
    select(x,y,density,area,geometry)
        
}

```

```{r examples-create_density_map}

library(ggplot2)
data("shape_courseulles")

# Create a map with a gradient density from the North with 500 individuals in the area

map_obj <- create_density_map(shape_obj = shape_courseulles,
                              N = 500,
                              grid_size = 1000,
                              density_type = "gradient",
                              gradient_direction = "N",
                              wavelength = 40000,
                              amplitude = 15
                              
)


ggplot() +
  geom_sf(data = map_obj, aes(fill = density))


# Create a map with a random density from the North with 500 individuals in the area

map_obj <- create_density_map(shape_obj = shape_courseulles,
                              N = 500,
                              grid_size = 1000,
                              density_type = "random",
                              wavelength = 10000,
                              amplitude = 15,
                              nb_hotspots = 10
                              
)


# Plot results
ggplot() +
  geom_sf(data = map_obj, aes(fill = density))


```

```{r tests-create_density_map}

```

## Simulate individuals with a inhomogenous Poisson point process.

From an sf class density map `map_obj` (data.frame), an inohomogene Poisson point process is used to simulate the presence of individuals in the study area. The probability of presence of an individual is dependent on the density given by the map. 

```{r function-simulate_ind}

#' Simulate individuals with a inhomogenous Poisson point process
#'
#' @param map_obj Dataframe. Sf map with a colum containg density informations density_m
#'
#' @importFrom glue glue
#' @importFrom assertthat assert_that
#' @importFrom dplyr mutate select filter
#' @importFrom sf st_centroid st_coordinates st_crs
#' @importFrom sp coordinates<- proj4string<- gridded<- CRS
#' @importFrom maptools as.im.SpatialGridDataFrame
#'
#' @return Dataframe. Les localisations des individus.
#' @export

simulate_ind <- function(map_obj) {
  
  # Function checks
  
  
  assert_that(inherits(map_obj, "sf"))
  if (!all(c("density") %in% names(map_obj))) {stop("map_obj must contain `density` column. Verify your column names.")}
  assert_that(is.numeric(map_obj$density))
  
  
  # Function 
  # st_make_grid
  
  # Create grid
  grid <- map_obj %>%
    st_centroid() %>%
    mutate(X = st_coordinates(.)[,1],
           Y = st_coordinates(.)[,2]) %>%
    as.data.frame() %>%
    select("X","Y","density")
  
  
  # Convert in grid class
  coordinates(grid) <- ~ X + Y
  proj4string(grid) <- CRS(st_crs(2154)$proj4string)
  gridded(grid) <- TRUE
  X_grid <- maptools::as.im.SpatialGridDataFrame(grid)
  
  # Inhomogenous Poisson point process
  ppp <- spatstat.core::rpoispp(lambda = X_grid, drop = TRUE)
  sim_ind <- data.frame(x = ppp$x, y = ppp$y)
  
  # Possibility to add group size
  sim_ind <- sim_ind %>%
    mutate(size = 1)
  
  return(sim_ind)
  
}

```

### Example

An example of this function use a dataset `dataset_map` consisting in a dataframe of class `sf` containing density information. 

From this map, the aim of the function `simulate_ind` is to simulate the presence of individuals in the study area. The function return a dataframe, here `ind`, containing the differents individuals simulated and their geographic coordinates. 

```{r examples-simulate_ind, warning = FALSE}

library(ggplot2)
data("shape_courseulles")

# First, create a map with a gradient density from the North with 500 individuals in the area
map_obj <- create_density_map(shape_obj = shape_courseulles,
                              N = 200,
                              grid_size = 1000,
                              density_type = "gradient",
                              gradient_direction = "N",
                              wavelength = 30000,
                              amplitude = 70
                              
)


# Then simulate the presence of individuals in the study area with a inhomogenous Poisson point process
obs_obj <- simulate_ind(map_obj = map_obj)


# Plot results
ggplot() +
    geom_sf(data = map_obj, aes(fill = density)) +
    geom_point(data = obs_obj, aes(x = x, y = y))
  
```

```{r tests-simulate_ind}
library(testthat)
library(dplyr)


# test_that("simulate_ind works", {
#   expect_true(inherits(simulate_ind, "function")) 
# })
# 
# 
# test_that("test conformite simulate_ind", {
# 
# data(dataset_map)
#   
# set.seed(2022)
# 
# test <- dataset_map %>%
#   simulate_ind(crs = 2154) %>%
#   slice(1:5)
# 
# exp <- structure(list(x = c(-158584.912826839, -141015.496673129, -158621.360360711,
# -149192.202820974, -167924.465316414), y = c(6267512.74100274,
# 6260473.11083696, 6254327.17926151, 6247672.87125581, 6253764.45961048
# ), size = c(1, 1, 1, 1, 1)), class = "data.frame", row.names = c(NA,
# -5L))
# 
# expect_equal(object = test,
#              expected = exp)
# 
# expect_is(test, "data.frame")
# 
# })
# 
# test_that("test erreur simulate ind", {
# 
# data(iris)
# 
# expect_error(object = simulate_ind(iris, crs = 2154))
# 
# data("dataset_map")
# 
# dataset_map_test <- dataset_map %>%
#   rename(nop = density_m)
# 
# expect_error(object = simulate_ind(dataset_map_test, crs=2154))
# 
# dataset_map_test <- dataset_map
# dataset_map_test$density_m[5] <- "nop"
# 
# expect_error(object = simulate_ind(dataset_map_test, crs=2154))
# 
# 
# })

```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console gradient_directionectly
fusen::inflate(flat_file = "dev/flat_population_abundance_emulator.Rmd", 
               vignette_name = "Population Abundance Emulator",
               open_vignette = FALSE,
               check = FALSE,
               overwrite = TRUE)
```
