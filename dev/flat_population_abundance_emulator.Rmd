---
title: "flat_minimal.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

## Simulate density map

This function allows to simulate different densities in the studied area:     

* A `homogenous` density with the same density througout the studied aera.
* A `gradient` density with a density decreasing from a hotspot that could be placed on different direction `gradient_direction`: `N` for North, `NE` for North-East, `E` for East, `SE` for South-East, `S` for South, `SW` for South-West, `W` for West, `NW` for North-West and `C` for center). The `amplitude` and the `wavelength` of the hotspot created can be modified.
* A `random` density, created by adding a certain number of hotspots `nb_hotspots` on the study area. The hotspot created have a maximum `amplitude` and a maximum `wavelength` that can be modified. Each hotspot created have an amplitude and a wavelength randomly chosen between 1 and a maximum `amplitude` and a maximum `wavelength` that can be modified by the user. 

The output is a map in sf dataframe contaning the simulated density. The dataframe contains two columns, `density` simulated for each square of the grid and `geometry` of the grid. 

```{r function-simulate_density}


#' Simulate density map
#'
#' @description
#' `simulate_density` allows to simulate density with different spatial variation. 
#'
#' @details
#' This function use create the `make.density` and the `add.hotspot` functions of the `dsims` package.
#'
#' To simulate density on the map, a grid is created. The length of square side could be chosen by the user with `grid_size`. 
#'
#' If `density_type` is '`gradient`', one hotspot is added on one direction `gradient_direction` (`N` for North, `NE` for North-East, `E` for East, `SE` for South-East, `S` for South, `SW` for South-West, `W` for West, `NW` for North-West and `C` for center). The hotspot added have a `amplitude` and a `wavelength` chosen by the user. 
#'
#' If `density_type` is '`random`', several hotspots, the number is chosen by the user with the argument `nb_hotspots`, are added randomly in the area.The amplitude and wavelength of the differents hotspot are chosen randomly between a minimum of 1 and a maximum corresponding to the `amplitude` and `wavelength` chosen by the user. 
#'
#'
#' @param shape_obj sf object. The shape of the study site.
#' @param grid_size Numeric. Length of length of square side. By default: 1000.
#' @param density_type Character. 'uniform", 'gradient', 'random', 'covariate'.
#' @param gradient_direction Character. Only for "gradient" `density_type`. Where the highest density comes from. 'N','NE','E'...
#' @param wavelength Numeric. Only for "gradient" and "random" `density_type`. Wavelength of the hotspots of density created. Maximum wavelength for "random" `density_type`. 
#' @param amplitude Numeric. Only for "gradient" and "random" `density_type`. Amplitude of the hotspots of density created. Maximum amplitude for "random" `density_type`. 
#' @param nb_hotspots Numeric. Only for "random" `density_type`. Number of random hotspots to be created.
#' @param crs Numeric. Only for "random" `density_type`. Number of random hotspots to be created. By default: 2154.
#'
#' @importFrom sf st_area st_sfc st_contains as_Spatial st_point st_sf st_transform
#' @importFrom sp bbox
#' @importFrom dssd make.region
#' @importFrom dsims make.density add.hotspot
#' @importFrom dplyr mutate filter select
#' @importFrom units drop_units
#' @importFrom stats runif
#' @importFrom assertthat assert_that
#'
#' @return The map in a sf dataframe contaning the simulated density. The dataframe contains two columns, `density` simulated for each square of the grid and `geometry` of the grid. 
#' @export

simulate_density <- function(shape_obj, grid_size = 1000, density_type, gradient_direction, wavelength, amplitude, nb_hotspots, crs = 2154) {
  
  
  # function checks
  assert_that(inherits(shape_obj, "sf"))
  assert_that(is.numeric(grid_size))
  assert_that(is.numeric(crs))
  if(!(density_type %in% c("random","gradient","uniform"))){stop("Density_type argument must be 'random', 'gradient', or 'uniform'.")}

  # function
  shape_obj <- shape_obj %>%
    st_transform(crs = crs)
  
  xlim <- bbox(as_Spatial(shape_obj))[1, ]
  ylim <- bbox(as_Spatial(shape_obj))[2, ]
  
  
  region_obj <- make.region(region.name = "Study site",
                            shape = shape_obj,
                            units = "m")
  
  if(density_type == "uniform"){ 
    
    density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
    
  }
  
  
  if(density_type == "gradient"){
    
    if(!(gradient_direction %in% c("N", "NE","E","SE","S","SW","W","NW","C"))){stop("Gradient_direction argument must be 'N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' or 'C'.")}
    assert_that(is.numeric(amplitude))
    assert_that(is.numeric(wavelength))

    
    if(gradient_direction == "N") {          
      x <- mean(xlim)  
      y <- max(ylim) + (max(ylim) - min(ylim))
    }
    if(gradient_direction == "NE") {
      x <- max(xlim)  
      y <- max(ylim)
    }
    
    if(gradient_direction == "E"){
      x <- max(xlim) + (max(xlim) - min(xlim))  
      y <- mean(ylim)
    }
    
    if(gradient_direction == "SE"){
      x <- max(xlim) 
      y <- min(ylim)
    }
    
    if(gradient_direction == "S") {
      x <- mean(xlim)  
      y <- min(ylim) - (max(ylim) - min(ylim)) 
    }
    
    if(gradient_direction == "SW"){
      x <- min(xlim)  
      y <- min(ylim)
    }
    
    if(gradient_direction == "W"){
      x <- min(xlim) - (max(xlim) - min(xlim))  
      y <- mean(ylim) 
    }
    
    if(gradient_direction == "NW"){
      x <- min(xlim)
      y <- max(ylim)
    }
    
    if(gradient_direction == "C"){
      x <- mean(xlim)
      y <- mean(ylim)
    }
    
    density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
    
    density_obj <- add.hotspot(object = density_obj,
                               centre = c(x, y),
                               sigma = wavelength,
                               amplitude = amplitude)
    
  }
  

    if(density_type == "random"){

    assert_that(is.numeric(amplitude))
    assert_that(is.numeric(wavelength))
    assert_that(is.numeric(nb_hotspots))
    
      
          density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
          
          for(i in 1:nb_hotspots){
            
            sigma_n <- runif(1, 1, wavelength)
            amplitude_n <- runif(1, 1, amplitude)
            
            x <- runif(1, xlim[1], xlim[2])
            y <- runif(1, ylim[1], ylim[2])
            
            point <- st_sfc(st_point(c(x,y)), crs = crs)
            a <- as.numeric(st_contains(shape_obj, point))
            
            while(is.na(a==1)){
              
              x <- runif(1, xlim[1], xlim[2])
              y <- runif(1, ylim[1], ylim[2])
              
              point <- st_sfc(st_point(c(x,y)), crs = crs)
              
              a <- as.numeric(st_contains(shape_obj, point))
            }
            
            density_obj <- add.hotspot(object = density_obj,
                                       centre = c(x, y),
                                       sigma = sigma_n,
                                       amplitude = amplitude_n)
            
            rm(a, x, y, sigma_n, amplitude_n)
            
          }
    }
      

    
  # if(density_type == "covariate") {
  #   
  #   density_obj <- make.density(region = region_obj,
  #                               x.space = grid_size,
  #                               y.space = grid_size,
  #                               constant = 1)
  # }
  
  
  map_obj <- density_obj@density.surface %>%
    as.data.frame() %>%
    st_sf(crs = crs) %>%
    mutate(area = st_area(.)) %>%
    mutate(area_grid = grid_size^2) %>%
    drop_units() %>%
    filter(area == area_grid) %>%
    select(density, geometry)
  
}

```

### Examples

For this example, we used a `shape_obj` that is included in this package `shape_courseulles`. We create a map contaning 500 individuals with: 
- (1) a gradient density. 
- (2) a random density. 

```{r examples-simulate_density}

library(ggplot2)
data("shape_courseulles")

# ------------------------------
# Example 1 : Create a map with a gradient density from the North with 500 individuals in the area

map <- simulate_density(shape_obj = shape_courseulles,
                              density_type = "gradient",
                              gradient_direction = "N",
                              wavelength = 40000,
                              amplitude = 15)

# Plot
ggplot() +
  geom_sf(data = map, aes(fill = density))


# ------------------------------
# Example 2 : Create a map with a random density from the North with 500 individuals in the area

map <- simulate_density(shape_obj = shape_courseulles,
                              density_type = "random",
                              wavelength = 10000,
                              amplitude = 15,
                              nb_hotspots = 10
                              
)

# Plot 
ggplot() +
  geom_sf(data = map, aes(fill = density))

```

```{r tests-simulate_density}
library(testthat)
library(dplyr)


test_that("simulate_density works", {
  expect_true(inherits(simulate_density, "function")) 
})


test_that("test conformite simulate_density", {
  
  data("shape_courseulles")
  
  set.seed(2022)
  
  # First, create a density map
  test_1 <- simulate_density(shape_obj = shape_courseulles,
                            density_type = "gradient",
                            gradient_direction = "NW",
                            wavelength = 20000,
                            amplitude = 500) %>%
    slice(1:5)
  
  
  
  
  test_2 <- simulate_density(shape_obj = shape_courseulles,
                              density_type = "random",
                              wavelength = 10000,
                              amplitude = 15,
                              nb_hotspots = 10) %>%
    slice(1:5)
  
  
  test_3 <- simulate_density(shape_obj = shape_courseulles,
                             density_type = "uniform") %>%
    slice(1:5)
  
  
  exp_1 <- structure(list(density = c(1.06893079882588, 1.05714563936609, 
1.04725710843882, 1.03898212024591, 1.03207583958285), geometry = structure(list(
    structure(list(structure(c(462199.599999965, 462199.599999965, 
    463199.599999965, 463199.599999965, 462199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(463199.599999965, 463199.599999965, 
    464199.599999965, 464199.599999965, 463199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(464199.599999965, 464199.599999965, 
    465199.599999965, 465199.599999965, 464199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(465199.599999965, 465199.599999965, 
    466199.599999965, 466199.599999965, 465199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(466199.599999965, 466199.599999965, 
    467199.599999965, 467199.599999965, 466199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg"))), class = c("sfc_POLYGON", 
"sfc"), precision = 0, bbox = structure(c(xmin = 462199.599999965, 
ymin = 6915158.74575047, xmax = 467199.599999965, ymax = 6916158.74575047
), class = "bbox"), crs = structure(list(input = "EPSG:2154", 
    wkt = "PROJCRS[\"RGF93 / Lambert-93\",\n    BASEGEOGCRS[\"RGF93\",\n        DATUM[\"Reseau Geodesique Francais 1993\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4171]],\n    CONVERSION[\"Lambert-93\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",46.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",3,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",44,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",700000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",6600000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"unknown\"],\n        AREA[\"France\"],\n        BBOX[41.15,-9.86,51.56,10.38]],\n    ID[\"EPSG\",2154]]"), class = "crs"), n_empty = 0L)), row.names = c(NA, 
-5L), class = c("sf", "data.frame"), sf_column = "geometry", agr = structure(c(density = NA_integer_), class = "factor", .Label = c("constant", 
"aggregate", "identity")))
    
  exp_2 <- structure(list(density = c(2.35446082022629, 2.3832927533325, 
2.39117051553099, 2.37776579546915, 2.34373415502516), geometry = structure(list(
    structure(list(structure(c(462199.599999965, 462199.599999965, 
    463199.599999965, 463199.599999965, 462199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(463199.599999965, 463199.599999965, 
    464199.599999965, 464199.599999965, 463199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(464199.599999965, 464199.599999965, 
    465199.599999965, 465199.599999965, 464199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(465199.599999965, 465199.599999965, 
    466199.599999965, 466199.599999965, 465199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(466199.599999965, 466199.599999965, 
    467199.599999965, 467199.599999965, 466199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg"))), class = c("sfc_POLYGON", 
"sfc"), precision = 0, bbox = structure(c(xmin = 462199.599999965, 
ymin = 6915158.74575047, xmax = 467199.599999965, ymax = 6916158.74575047
), class = "bbox"), crs = structure(list(input = "EPSG:2154", 
    wkt = "PROJCRS[\"RGF93 / Lambert-93\",\n    BASEGEOGCRS[\"RGF93\",\n        DATUM[\"Reseau Geodesique Francais 1993\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4171]],\n    CONVERSION[\"Lambert-93\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",46.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",3,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",44,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",700000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",6600000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"unknown\"],\n        AREA[\"France\"],\n        BBOX[41.15,-9.86,51.56,10.38]],\n    ID[\"EPSG\",2154]]"), class = "crs"), n_empty = 0L)), row.names = c(NA, 
-5L), class = c("sf", "data.frame"), sf_column = "geometry", agr = structure(c(density = NA_integer_), class = "factor", .Label = c("constant", 
"aggregate", "identity")))
    
  exp_3 <- structure(list(density = c(1, 1, 1, 1, 1), geometry = structure(list(
    structure(list(structure(c(462199.599999965, 462199.599999965, 
    463199.599999965, 463199.599999965, 462199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(463199.599999965, 463199.599999965, 
    464199.599999965, 464199.599999965, 463199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(464199.599999965, 464199.599999965, 
    465199.599999965, 465199.599999965, 464199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(465199.599999965, 465199.599999965, 
    466199.599999965, 466199.599999965, 465199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg")), 
    structure(list(structure(c(466199.599999965, 466199.599999965, 
    467199.599999965, 467199.599999965, 466199.599999965, 6915158.74575047, 
    6916158.74575047, 6916158.74575047, 6915158.74575047, 6915158.74575047
    ), .Dim = c(5L, 2L))), class = c("XY", "POLYGON", "sfg"))), class = c("sfc_POLYGON", 
"sfc"), precision = 0, bbox = structure(c(xmin = 462199.599999965, 
ymin = 6915158.74575047, xmax = 467199.599999965, ymax = 6916158.74575047
), class = "bbox"), crs = structure(list(input = "EPSG:2154", 
    wkt = "PROJCRS[\"RGF93 / Lambert-93\",\n    BASEGEOGCRS[\"RGF93\",\n        DATUM[\"Reseau Geodesique Francais 1993\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4171]],\n    CONVERSION[\"Lambert-93\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",46.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",3,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",44,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",700000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",6600000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"unknown\"],\n        AREA[\"France\"],\n        BBOX[41.15,-9.86,51.56,10.38]],\n    ID[\"EPSG\",2154]]"), class = "crs"), n_empty = 0L)), row.names = c(NA, 
-5L), class = c("sf", "data.frame"), sf_column = "geometry", agr = structure(c(density = NA_integer_), class = "factor", .Label = c("constant", 
"aggregate", "identity")))
    
expect_equal(object = test_1,
             expected = exp_1)

expect_equal(object = test_2,
             expected = exp_2)

expect_equal(object = test_3,
             expected = exp_3)

expect_is(test_1, "data.frame")
expect_is(test_2, "data.frame")
expect_is(test_3, "data.frame")

})

test_that("test erreur simulate_density", {
  
  data("shape_courseulles")
  
  
  expect_error(object = simulate_density(shape_obj = c(1,1,1),
                                           density_type = "uniform"))
  
  expect_error(object = simulate_density(shape_obj = shape_courseulles,
                                          density_type = "aleatoire"))
  
  expect_error(object = simulate_density(shape_obj = shape_courseulles,
                                           density_type = "gradient",
                                           gradient_direction = "SSE",
                                           wavelength = 40000,
                                           amplitude = 15))
  
  expect_error(object = simulate_density(shape_obj = shape_courseulles,
                                           density_type = "gradient",
                                           gradient_direction = "SE",
                                           amplitude = 15))
  
  expect_error(object = simulate_density(shape_obj = shape_courseulles,
                                           gradient_direction = "NE",
                                           density_type = "gradient",
                                           wavelength = "ohoh",
                                           amplitude = 15))
  
  expect_error(object = simulate_density(shape_obj = shape_courseulles,
                                           density_type = "random",
                                           wavelength = 40000,
                                           amplitude = 15))
  
  expect_error(object = simulate_density(shape_obj = shape_courseulles,
                                           density_type = "random",
                                           wavelength = 40000,
                                           amplitude = 15,
                                           nb_hotspots = "haha"))
  
  
})
```

## Simulate individuals with a inhomogenous Poisson point process.

From an sf class density map `map_obj` (data.frame), an inohomogene Poisson point process is used to simulate the presence of individuals in the study area. The probability of presence of an individual is dependent on the density given by the map. 

Then, the correct density ratios are calcultating according to the desired number of individuals in the area `N`. 

```{r function-simulate_ind}

#' Simulate individuals with a inhomogenous Poisson point process
#'
#' @param map_obj sf dataframe. Sf map with a colum containg density informations
#' @param N Numeric. The number of individuals desired in the area.
#' @param crs numeric. Projection system. By default = 2154. 
#'
#' @importFrom glue glue
#' @importFrom assertthat assert_that
#' @importFrom dplyr mutate select filter
#' @importFrom sf st_centroid st_coordinates st_crs st_area
#' @importFrom sp coordinates<- proj4string<- gridded<- CRS
#' @importFrom maptools as.im.SpatialGridDataFrame
#'
#' @return Dataframe. Les localisations des individus.
#' @export



simulate_ind <- function(map_obj, N, crs = 2154) {
  
  # Function checks
  assert_that(inherits(map_obj, "sf"))
  if (!all(c("density") %in% names(map_obj))) {stop("map_obj must contain `density` column. Verify your column names.")}
  assert_that(is.numeric(map_obj$density))
  assert_that(is.numeric(crs))
  assert_that(is.numeric(N))

  
  map_obj <- map_obj %>%
    mutate(area = st_area(.))
  
  # Function 
  total_area <- sum(map_obj$area)
  average_density <- N / total_area
  
  map_obj <- map_obj %>%
    mutate(density = average_density * density / mean(density, na.rm = TRUE))
  
  # Create grid
  grid <- map_obj %>%
    st_centroid() %>%
    mutate(X = st_coordinates(.)[,1],
           Y = st_coordinates(.)[,2]) %>%
    as.data.frame() %>%
    select("X","Y","density")
  
  
  # Convert in grid class
  coordinates(grid) <- ~ X + Y
  proj4string(grid) <- CRS(st_crs(crs)$proj4string)
  gridded(grid) <- TRUE
  X_grid <- maptools::as.im.SpatialGridDataFrame(grid)
  
  # Inhomogenous Poisson point process
  ppp <- spatstat.core::rpoispp(lambda = X_grid, drop = TRUE)
  sim_ind <- data.frame(x = ppp$x, y = ppp$y)
  
  # Possibility to add group size
  sim_ind <- sim_ind %>%
    mutate(size = 1)
  
  return(sim_ind)
  
}

```

### Example

An example of this function use a dataset `dataset_map` consisting in a dataframe of class `sf` containing density information. 

From this map, the aim of the function `simulate_ind` is to simulate the presence of individuals in the study area. The function return a dataframe, here `ind`, containing the differents individuals simulated and their geographic coordinates. 

```{r examples-simulate_ind, warning = FALSE}

library(ggplot2)
data("shape_courseulles")

# First, create a map with a gradient density from the North with 500 individuals in the area
map <- simulate_density(shape_obj = shape_courseulles,
                              grid_size = 1000,
                              density_type = "gradient",
                              gradient_direction = "N",
                              wavelength = 20000,
                              amplitude = 100)

# Then simulate the presence of individuals in the study area 
ind <- simulate_ind(map_obj = map, N = 200)

# Plot
ggplot() +
    geom_sf(data = map, aes(fill = density)) +
    geom_point(data = ind, aes(x = x, y = y))
  
```

```{r tests-simulate_ind}
library(testthat)
library(dplyr)


test_that("simulate_ind works", {
  expect_true(inherits(simulate_ind, "function")) 
})


test_that("test conformite simulate_ind", {
  
  data("shape_courseulles")
  
  set.seed(2022)
  
  # First, create a density map
  map <- simulate_density(shape_obj = shape_courseulles,
                            density_type = "gradient",
                            gradient_direction = "N",
                            wavelength = 20000,
                            amplitude = 500)
  
  test <- simulate_ind(map_obj = map, N = 500) %>%
                 slice(1:5)

exp <- structure(list(x = c(432098.238355977, 420533.286240681, 434527.738948383, 
411815.477216414, 470612.945042581), y = c(6952762.23628262, 
6944532.6011364, 6950771.26691599, 6944138.62147687, 6945281.02163264
), size = c(1, 1, 1, 1, 1)), class = "data.frame", row.names = c(NA, 
-5L))

  expect_equal(object = test,
               expected = exp)

  expect_is(test, "data.frame")

})

test_that("test erreur simulate ind", {
  
  data(iris)
  
  expect_error(object = simulate_ind(map_obj = iris, N = 500))
  
  # First, create a density map
  map <- simulate_density(shape_obj = shape_courseulles,
                            density_type = "gradient",
                            gradient_direction = "N",
                            wavelength = 20000,
                            amplitude = 500)
  
  expect_error(object = simulate_ind(map_obj = map, N = "haha"))
  expect_error(object = simulate_ind(map_obj = map))

  
  map_test <- map %>%
    rename(nop = density)
  
  expect_error(object = simulate_ind(map_obj = map_test,N = 500))
  
  map_test <- map
  map_test$density[5] <- "nop"
  
  expect_error(object = simulate_ind(map_obj = map_test, N = 500))
  
  expect_error(object = simulate_ind(map_obj = map,
                                     N = 500,
                                     crs = "nop"))
  
})

```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console gradient_directionectly
fusen::inflate(flat_file = "dev/flat_population_abundance_emulator.Rmd", 
               vignette_name = "Population Abundance Emulator",
               open_vignette = FALSE,
               check = FALSE,
               overwrite = TRUE)
```
