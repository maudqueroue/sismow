---
title: "flat_minimal.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.
-->

## Create density map

This function allows to create different densities in the studied area. 
- A `homogenous` density with the same density througout the studied aera.
- A `gradient` density with a density decreasing from a hotspot that could be placed on different direction `gradient_direction` (`N` for North, `NE` for North-East, `E` for East, `SE` for South-East, `S` for South, `SW` for South-West, `W` for West, `NW` for North-West and `C` for center). The `amplitude` and the `wavelength` of the hotspot created can be modified.
- A `random` density, created by adding a certain number of hotspots `nb_hotspots` on the study area. The hotspot created have a maximum `amplitude` and a maximum `wavelength` that can be modified. Each hotspot created have an amplitude and a wavelength randomly choosen between 1 and a maximum `amplitude` and a maximum `wavelength` that can be modified. 
Then, the correct density ratios are calcultating according to the desired number of individuals in the area `N`.  

```{r function-create_density_map}


#' Create a map with the desired density of individuals
#'
#' @param shape_obj sf object. The shape of the study site.
#' @param N Numeric. The number of individuals desired in the area.
#' @param grid_size Numeric. Grid size in m. By default = 1000
#' @param density_type Character. 'uniform", 'gradient', 'random', 'covariate'.
#' @param gradient_direction Character. Only for "gradient" `density_type`. Where the highest density comes from. 'N','NE','E'...
#' @param wavelength Numeric. Only for "gradient" and "random" `density_type`. Wavelength of the hotspots of density created. Maximum wavelength for "random" `density_type`. 
#' @param amplitude Numeric. Only for "gradient" and "random" `density_type`. Amplitude of the hotspots of density created. Maximum amplitude for "random" `density_type`. 
#' @param nb_hotspots Numeric. Only for "random" `density_type`. Number of random hotspots to be created.
#' @param crs Numeric. Only for "random" `density_type`. Number of random hotspots to be created. By default = 2154
#'
#' @importFrom sf st_area st_sfc st_contains as_Spatial st_point st_sf st_transform
#' @importFrom sp bbox
#' @importFrom dssd make.region
#' @importFrom dsims make.density add.hotspot
#' @importFrom dplyr mutate filter select
#' @importFrom units drop_units
#' @importFrom stats runif
#' @importFrom assertthat assert_that
#'
#' @return sf object. The map with the densities type choosen and corresponding to the number of individuals desired in the study area. 
#' @export

create_density_map <- function(shape_obj, N, grid_size = 1000, density_type, gradient_direction, wavelength, amplitude, nb_hotspots, crs = 2154) {
  
  
  # function checks
  assert_that(inherits(shape_obj, "sf"))
  assert_that(is.numeric(N))
  assert_that(is.numeric(grid_size))
  assert_that(is.numeric(crs))
  if(!(density_type %in% c("random","gradient","uniform"))){stop("Density_type argument must be 'random', 'gradient', or 'uniform'.")}

  # function
  shape_obj <- shape_obj %>%
    st_transform(crs = crs)
  
  xlim <- bbox(as_Spatial(shape_obj))[1, ]
  ylim <- bbox(as_Spatial(shape_obj))[2, ]
  
  
  region_obj <- make.region(region.name = "Study site",
                            shape = shape_obj,
                            units = "m")
  
  if(density_type == "uniform"){ 
    
    density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
    
  }
  
  
  if(density_type == "gradient"){
    
    if(!(gradient_direction %in% c("N", "NE","E","SE","S","SW","W","NW","C"))){stop("Gradient_direction argument must be 'N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' or 'C'.")}
    assert_that(is.numeric(amplitude))
    assert_that(is.numeric(wavelength))

    
    if(gradient_direction == "N") {          
      x <- mean(xlim)  
      y <- max(ylim) + (max(ylim) - min(ylim))
    }
    if(gradient_direction == "NE") {
      x <- max(xlim)  
      y <- max(ylim)
    }
    
    if(gradient_direction == "E"){
      x <- max(xlim) + (max(xlim) - min(xlim))  
      y <- mean(ylim)
    }
    
    if(gradient_direction == "SE"){
      x <- max(xlim) 
      y <- min(ylim)
    }
    
    if(gradient_direction == "S") {
      x <- mean(xlim)  
      y <- min(ylim) - (max(ylim) - min(ylim)) 
    }
    
    if(gradient_direction == "SW"){
      x <- min(xlim)  
      y <- min(ylim)
    }
    
    if(gradient_direction == "W"){
      x <- min(xlim) - (max(xlim) - min(xlim))  
      y <- mean(ylim) 
    }
    
    if(gradient_direction == "NW"){
      x <- min(xlim)
      y <- max(ylim)
    }
    
    if(gradient_direction == "C"){
      x <- mean(xlim)
      y <- mean(ylim)
    }
    
    density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
    
    density_obj <- add.hotspot(object = density_obj,
                               centre = c(x, y),
                               sigma = wavelength,
                               amplitude = amplitude)
    
  }
  

    if(density_type == "random"){

    assert_that(is.numeric(amplitude))
    assert_that(is.numeric(wavelength))
    assert_that(is.numeric(nb_hotspots))
    
      
          density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
          
          for(i in 1:nb_hotspots){
            
            sigma_n <- runif(1, 1, wavelength)
            amplitude_n <- runif(1, 1, amplitude)
            
            x <- runif(1, xlim[1], xlim[2])
            y <- runif(1, ylim[1], ylim[2])
            
            point <- st_sfc(st_point(c(x,y)), crs = crs)
            a <- as.numeric(st_contains(shape_obj, point))
            
            while(is.na(a==1)){
              
              x <- runif(1, xlim[1], xlim[2])
              y <- runif(1, ylim[1], ylim[2])
              
              point <- st_sfc(st_point(c(x,y)), crs = crs)
              
              a <- as.numeric(st_contains(shape_obj, point))
            }
            
            density_obj <- add.hotspot(object = density_obj,
                                       centre = c(x, y),
                                       sigma = sigma_n,
                                       amplitude = amplitude_n)
            
            rm(a, x, y, sigma_n, amplitude_n)
            
          }
    }
      

    
  # if(density_type == "covariate") {
  #   
  #   density_obj <- make.density(region = region_obj,
  #                               x.space = grid_size,
  #                               y.space = grid_size,
  #                               constant = 1)
  # }
  
  
  map_obj <- density_obj@density.surface %>%
    as.data.frame() %>%
    st_sf(crs = crs) %>%
    mutate(area = st_area(.)) %>%
    mutate(area_grid = grid_size^2) %>%
    drop_units() %>%
    filter(area == area_grid)
  
  total_area <- sum(map_obj$area)
  average_density <- N / total_area

  map_obj <- map_obj %>%
    mutate(density = average_density * density / mean(density, na.rm = TRUE)) %>%
    select(x,y,density,area,geometry)
        
}

```

### Examples

For this example, we used a `shape_obj` that is included in this package `shape_courseulles`. We create a map contaning 500 individuals with: 
- (1) a gradient density. 
- (2) a random density. 

```{r examples-create_density_map}

library(ggplot2)
data("shape_courseulles")

# ------------------------------
# Example 1 : Create a map with a gradient density from the North with 500 individuals in the area

map <- create_density_map(shape_obj = shape_courseulles,
                              N = 500,
                              density_type = "gradient",
                              gradient_direction = "N",
                              wavelength = 40000,
                              amplitude = 15
                              
)

# Plot
ggplot() +
  geom_sf(data = map, aes(fill = density))


# ------------------------------
# Example 2 : Create a map with a random density from the North with 500 individuals in the area

map <- create_density_map(shape_obj = shape_courseulles,
                              N = 500,
                              density_type = "random",
                              wavelength = 10000,
                              amplitude = 15,
                              nb_hotspots = 10
                              
)

# Plot 
ggplot() +
  geom_sf(data = map, aes(fill = density))

```

```{r tests-create_density_map}
library(testthat)
library(dplyr)


test_that("create_obs works", {
  expect_true(inherits(create_obs, "function")) 
})


test_that("test conformite create_density_map", {
  
  data("shape_courseulles")
  
  set.seed(2022)
  
  # First, create a density map
  test_1 <- create_density_map(shape_obj = shape_courseulles,
                            N = 1000,
                            density_type = "gradient",
                            gradient_direction = "NW",
                            wavelength = 20000,
                            amplitude = 500) %>%
    slice(1:5)
  
  
  
  
  test_2 <- create_density_map(shape_obj = shape_courseulles,
                              N = 500,
                              density_type = "random",
                              wavelength = 10000,
                              amplitude = 15,
                              nb_hotspots = 10) %>%
    slice(1:5)
  
  
  test_3 <- create_density_map(shape_obj = shape_courseulles,
                              N = 500,
                              density_type = "uniform") %>%
    slice(1:5)
  
  
  exp_1 <- structure(list(x = c(462699.599999965, 463699.599999965, 464699.599999965, 
465699.599999965, 466699.599999965), y = c(6915658.74575047, 
6915658.74575047, 6915658.74575047, 6915658.74575047, 6915658.74575047
), density = c(5.23196832511851e-09, 5.17428490813041e-09, 5.12588469302738e-09, 
5.08538209345446e-09, 5.0515787436836e-09), area = c(1e+06, 1e+06, 
1e+06, 1e+06, 1e+06), geometry = structure(list(structure(list(
    structure(c(462199.599999965, 462199.599999965, 463199.599999965, 
    463199.599999965, 462199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(463199.599999965, 463199.599999965, 464199.599999965, 
    464199.599999965, 463199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(464199.599999965, 464199.599999965, 465199.599999965, 
    465199.599999965, 464199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(465199.599999965, 465199.599999965, 466199.599999965, 
    466199.599999965, 465199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(466199.599999965, 466199.599999965, 467199.599999965, 
    467199.599999965, 466199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg"))), class = c("sfc_POLYGON", 
"sfc"), precision = 0, bbox = structure(c(xmin = 462199.599999965, 
ymin = 6915158.74575047, xmax = 467199.599999965, ymax = 6916158.74575047
), class = "bbox"), crs = structure(list(input = "EPSG:2154", 
    wkt = "PROJCRS[\"RGF93 / Lambert-93\",\n    BASEGEOGCRS[\"RGF93\",\n        DATUM[\"Reseau Geodesique Francais 1993\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4171]],\n    CONVERSION[\"Lambert-93\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",46.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",3,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",44,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",700000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",6600000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"unknown\"],\n        AREA[\"France\"],\n        BBOX[41.15,-9.86,51.56,10.38]],\n    ID[\"EPSG\",2154]]"), class = "crs"), n_empty = 0L)), row.names = c(NA, 
-5L), class = c("sf", "data.frame"), sf_column = "geometry", agr = structure(c(x = NA_integer_, 
y = NA_integer_, density = NA_integer_, area = NA_integer_), class = "factor", .Label = c("constant", 
"aggregate", "identity")))
    
  exp_2 <- structure(list(x = c(462699.599999965, 463699.599999965, 464699.599999965, 
465699.599999965, 466699.599999965), y = c(6915658.74575047, 
6915658.74575047, 6915658.74575047, 6915658.74575047, 6915658.74575047
), density = c(7.17061580681248e-08, 7.25842474952084e-08, 7.28241682688207e-08, 
7.24159215197748e-08, 7.13794726784813e-08), area = c(1e+06, 
1e+06, 1e+06, 1e+06, 1e+06), geometry = structure(list(structure(list(
    structure(c(462199.599999965, 462199.599999965, 463199.599999965, 
    463199.599999965, 462199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(463199.599999965, 463199.599999965, 464199.599999965, 
    464199.599999965, 463199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(464199.599999965, 464199.599999965, 465199.599999965, 
    465199.599999965, 464199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(465199.599999965, 465199.599999965, 466199.599999965, 
    466199.599999965, 465199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(466199.599999965, 466199.599999965, 467199.599999965, 
    467199.599999965, 466199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg"))), class = c("sfc_POLYGON", 
"sfc"), precision = 0, bbox = structure(c(xmin = 462199.599999965, 
ymin = 6915158.74575047, xmax = 467199.599999965, ymax = 6916158.74575047
), class = "bbox"), crs = structure(list(input = "EPSG:2154", 
    wkt = "PROJCRS[\"RGF93 / Lambert-93\",\n    BASEGEOGCRS[\"RGF93\",\n        DATUM[\"Reseau Geodesique Francais 1993\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4171]],\n    CONVERSION[\"Lambert-93\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",46.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",3,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",44,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",700000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",6600000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"unknown\"],\n        AREA[\"France\"],\n        BBOX[41.15,-9.86,51.56,10.38]],\n    ID[\"EPSG\",2154]]"), class = "crs"), n_empty = 0L)), row.names = c(NA, 
-5L), class = c("sf", "data.frame"), sf_column = "geometry", agr = structure(c(x = NA_integer_, 
y = NA_integer_, density = NA_integer_, area = NA_integer_), class = "factor", .Label = c("constant", 
"aggregate", "identity")))
    
  exp_3 <- structure(list(x = c(462699.599999965, 463699.599999965, 464699.599999965, 
465699.599999965, 466699.599999965), y = c(6915658.74575047, 
6915658.74575047, 6915658.74575047, 6915658.74575047, 6915658.74575047
), density = c(1.72950536146662e-07, 1.72950536146662e-07, 1.72950536146662e-07, 
1.72950536146662e-07, 1.72950536146662e-07), area = c(1e+06, 
1e+06, 1e+06, 1e+06, 1e+06), geometry = structure(list(structure(list(
    structure(c(462199.599999965, 462199.599999965, 463199.599999965, 
    463199.599999965, 462199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(463199.599999965, 463199.599999965, 464199.599999965, 
    464199.599999965, 463199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(464199.599999965, 464199.599999965, 465199.599999965, 
    465199.599999965, 464199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(465199.599999965, 465199.599999965, 466199.599999965, 
    466199.599999965, 465199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg")), structure(list(
    structure(c(466199.599999965, 466199.599999965, 467199.599999965, 
    467199.599999965, 466199.599999965, 6915158.74575047, 6916158.74575047, 
    6916158.74575047, 6915158.74575047, 6915158.74575047), .Dim = c(5L, 
    2L))), class = c("XY", "POLYGON", "sfg"))), class = c("sfc_POLYGON", 
"sfc"), precision = 0, bbox = structure(c(xmin = 462199.599999965, 
ymin = 6915158.74575047, xmax = 467199.599999965, ymax = 6916158.74575047
), class = "bbox"), crs = structure(list(input = "EPSG:2154", 
    wkt = "PROJCRS[\"RGF93 / Lambert-93\",\n    BASEGEOGCRS[\"RGF93\",\n        DATUM[\"Reseau Geodesique Francais 1993\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4171]],\n    CONVERSION[\"Lambert-93\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",46.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",3,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",44,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",700000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",6600000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"unknown\"],\n        AREA[\"France\"],\n        BBOX[41.15,-9.86,51.56,10.38]],\n    ID[\"EPSG\",2154]]"), class = "crs"), n_empty = 0L)), row.names = c(NA, 
-5L), class = c("sf", "data.frame"), sf_column = "geometry", agr = structure(c(x = NA_integer_, 
y = NA_integer_, density = NA_integer_, area = NA_integer_), class = "factor", .Label = c("constant", 
"aggregate", "identity")))
    
expect_equal(object = test_1,
             expected = exp_1)

expect_equal(object = test_2,
             expected = exp_2)

expect_equal(object = test_3,
             expected = exp_3)

expect_is(test_1, "data.frame")
expect_is(test_2, "data.frame")
expect_is(test_3, "data.frame")

})

test_that("test erreur create_density_map", {
  
  data("shape_courseulles")
  
  
  expect_error(object = create_density_map(shape_obj = c(1,1,1),
                                           N = 500,
                                           density_type = "uniform"))
  
  expect_error(object = create_density_map(shape_obj = shape_courseulles,
                                           N = "haha",
                                           density_type = "uniform"))
  
  expect_error(object = create_density_map(shape_obj = shape_courseulles,
                                           N = 500,
                                           density_type = "aleatoire"))
  
  expect_error(object = create_density_map(shape_obj = shape_courseulles,
                                           N = 500,
                                           density_type = "gradient",
                                           gradient_direction = "SSE",
                                           wavelength = 40000,
                                           amplitude = 15))
  
  expect_error(object = create_density_map(shape_obj = shape_courseulles,
                                           N = 500,
                                           density_type = "gradient",
                                           gradient_direction = "SE",
                                           amplitude = 15))
  
  expect_error(object = create_density_map(shape_obj = shape_courseulles,
                                           N = 500,
                                           gradient_direction = "NE",
                                           density_type = "gradient",
                                           wavelength = "ohoh",
                                           amplitude = 15))
  
  expect_error(object = create_density_map(shape_obj = shape_courseulles,
                                           N = 500,
                                           density_type = "random",
                                           wavelength = 40000,
                                           amplitude = 15))
  
  expect_error(object = create_density_map(shape_obj = shape_courseulles,
                                           N = 500,
                                           density_type = "random",
                                           wavelength = 40000,
                                           amplitude = 15,
                                           nb_hotspots = "haha"))
  
  
})
```

## Simulate individuals with a inhomogenous Poisson point process.

From an sf class density map `map_obj` (data.frame), an inohomogene Poisson point process is used to simulate the presence of individuals in the study area. The probability of presence of an individual is dependent on the density given by the map. 

```{r function-simulate_ind}

#' Simulate individuals with a inhomogenous Poisson point process
#'
#' @param map_obj sf dataframe. Sf map with a colum containg density informations
#' @param crs numeric. Projection system. By default = 2154. 
#'
#' @importFrom glue glue
#' @importFrom assertthat assert_that
#' @importFrom dplyr mutate select filter
#' @importFrom sf st_centroid st_coordinates st_crs
#' @importFrom sp coordinates<- proj4string<- gridded<- CRS
#' @importFrom maptools as.im.SpatialGridDataFrame
#'
#' @return Dataframe. Les localisations des individus.
#' @export



simulate_ind <- function(map_obj, crs = 2154) {
  
  # Function checks
  assert_that(inherits(map_obj, "sf"))
  if (!all(c("density") %in% names(map_obj))) {stop("map_obj must contain `density` column. Verify your column names.")}
  assert_that(is.numeric(map_obj$density))
  assert_that(is.numeric(crs))

  
  
  # Function 
  # st_make_grid
  
  # Create grid
  grid <- map_obj %>%
    st_centroid() %>%
    mutate(X = st_coordinates(.)[,1],
           Y = st_coordinates(.)[,2]) %>%
    as.data.frame() %>%
    select("X","Y","density")
  
  
  # Convert in grid class
  coordinates(grid) <- ~ X + Y
  proj4string(grid) <- CRS(st_crs(crs)$proj4string)
  gridded(grid) <- TRUE
  X_grid <- maptools::as.im.SpatialGridDataFrame(grid)
  
  # Inhomogenous Poisson point process
  ppp <- spatstat.core::rpoispp(lambda = X_grid, drop = TRUE)
  sim_ind <- data.frame(x = ppp$x, y = ppp$y)
  
  # Possibility to add group size
  sim_ind <- sim_ind %>%
    mutate(size = 1)
  
  return(sim_ind)
  
}

```

### Example

An example of this function use a dataset `dataset_map` consisting in a dataframe of class `sf` containing density information. 

From this map, the aim of the function `simulate_ind` is to simulate the presence of individuals in the study area. The function return a dataframe, here `ind`, containing the differents individuals simulated and their geographic coordinates. 

```{r examples-simulate_ind, warning = FALSE}

library(ggplot2)
data("shape_courseulles")

# First, create a map with a gradient density from the North with 500 individuals in the area
map <- create_density_map(shape_obj = shape_courseulles,
                              N = 200,
                              grid_size = 1000,
                              density_type = "gradient",
                              gradient_direction = "N",
                              wavelength = 20000,
                              amplitude = 500
                              
)


# Then simulate the presence of individuals in the study area 
ind <- simulate_ind(map_obj = map)


# Plot
ggplot() +
    geom_sf(data = map, aes(fill = density)) +
    geom_point(data = ind, aes(x = x, y = y))
  
```

```{r tests-simulate_ind}
library(testthat)
library(dplyr)


test_that("simulate_ind works", {
  expect_true(inherits(simulate_ind, "function")) 
})


test_that("test conformite simulate_ind", {
  
  data("shape_courseulles")
  
  set.seed(2022)
  
  # First, create a density map
  map <- create_density_map(shape_obj = shape_courseulles,
                            N = 1000,
                            density_type = "gradient",
                            gradient_direction = "N",
                            wavelength = 20000,
                            amplitude = 500)
  
  test <- simulate_ind(map_obj = map) %>%
                 slice(1:5)

exp <- structure(list(x = c(431775.072857303, 420574.950567477, 434997.642150412, 
411643.817603619, 471141.824978667), y = c(6953113.82923826, 
6944770.46572502, 6950439.73189654, 6943461.32505072, 6946109.31119641
), size = c(1, 1, 1, 1, 1)), class = "data.frame", row.names = c(NA, 
-5L))

  expect_equal(object = test,
               expected = exp)

  expect_is(test, "data.frame")

})

test_that("test erreur simulate ind", {
  
  data(iris)
  
  expect_error(object = simulate_ind(map_obj = iris))
  
  # First, create a density map
  map <- create_density_map(shape_obj = shape_courseulles,
                            N = 1000,
                            density_type = "gradient",
                            gradient_direction = "N",
                            wavelength = 20000,
                            amplitude = 500)
  
  map_test <- map %>%
    rename(nop = density)
  
  expect_error(object = simulate_ind(map_obj = map_test))
  
  map_test <- map
  map_test$density[5] <- "nop"
  
  expect_error(object = simulate_ind(map_obj = map_test))
  
  expect_error(object = simulate_ind(map_obj = map,
                                     crs = "nop"))
  
})

```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console gradient_directionectly
fusen::inflate(flat_file = "dev/flat_population_abundance_emulator.Rmd", 
               vignette_name = "Population Abundance Emulator",
               open_vignette = FALSE,
               check = FALSE,
               overwrite = TRUE)
```
