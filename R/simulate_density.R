# Generated by fusen: do not edit by hand



#' Simulate density maps
#'
#' @description
#' `simulate_density` allows to simulate density with different spatial variation. 
#'
#' @details
#' This function use create the `make.density` and the `add.hotspot` functions of the `dsims` package.
#'
#' To simulate density on the map, a grid is created. The length of square side could be chosen by the user with `grid_size`. 
#'
#' If `density_type` is '`gradient`', one hotspot is added on one direction `gradient_direction` (North, North-East, East, South-East, South, South-West, West, North-West and center). The hotspot added have a `amplitude` and a `wavelength` chosen by the user. 
#'
#' If `density_type` is '`random`', several hotspots, the number is chosen by the user with the argument `nb_hotspots`, are added randomly in the area.The amplitude and wavelength of the differents hotspot are chosen randomly between a minimum of 1 and a maximum corresponding to the `amplitude` and `wavelength` chosen by the user. 
#'
#'
#' @param shape_obj sf object. The shape of the study site.
#' @param grid_size numeric. Length of length of square side. By default: 1000.
#' @param density_type character. 'uniform", 'gradient', 'random', 'covariate'.
#' @param gradient_direction character. Only for "gradient" `density_type`. Where the highest density comes from. 'N' for North,'NE','E'... and 'C" for center
#' @param wavelength numeric. Only for "gradient" and "random" `density_type`. Wavelength of the hotspots of density created. Maximum wavelength for "random" `density_type`. 
#' @param amplitude numeric. Only for "gradient" and "random" `density_type`. Amplitude of the hotspots of density created. Maximum amplitude for "random" `density_type`. 
#' @param nb_hotspots numeric. Only for "random" `density_type`. Number of random hotspots to be created.
#' @param crs numeric. Only for "random" `density_type`. Number of random hotspots to be created. By default: 2154.
#'
#' @importFrom sf st_area st_sfc st_contains as_Spatial st_point st_sf st_transform
#' @importFrom sp bbox
#' @importFrom dssd make.region
#' @importFrom dsims make.density add.hotspot
#' @importFrom dplyr mutate filter select
#' @importFrom units drop_units
#' @importFrom stats runif
#' @importFrom assertthat assert_that
#'
#' @return The map in a sf dataframe contaning the simulated density. The dataframe contains two columns, `density` simulated for each square of the grid and `geometry` of the grid. 
#' @export

#' @examples
#' 
#' library(ggplot2)
#' data("shape_courseulles")
#' 
#' # ------------------------------
#' # Example 1: Simulate a map with a gradient density from the North
#' #-------------------------------
#' 
#' map <- simulate_density(shape_obj = shape_courseulles,
#'                               density_type = "gradient",
#'                               gradient_direction = "N",
#'                               wavelength = 20000,
#'                               amplitude = 10)
#' 
#' # Plot
#' ggplot() +
#'   geom_sf(data = map, aes(fill = density)) +
#'   theme(panel.background = element_rect(fill = "white"),
#'         panel.grid.major = element_line(colour = "#EDEDE9"))
#' 
#' 
#' # ------------------------------
#' # Example 2: Simulate a map with a random density
#' # ------------------------------
#' 
#' map <- simulate_density(shape_obj = shape_courseulles,
#'                               density_type = "random",
#'                               wavelength = 10000,
#'                               amplitude = 15,
#'                               nb_hotspots = 10
#'                               
#' )
#' 
#' # Plot 
#' ggplot() +
#'   geom_sf(data = map, aes(fill = density)) +
#'   theme(panel.background = element_rect(fill = "white"),
#'         panel.grid.major = element_line(colour = "#EDEDE9"))
#' 
simulate_density <- function(shape_obj, grid_size = 1000, density_type, gradient_direction, wavelength, amplitude, nb_hotspots, crs = 2154) {
  
  
  # function checks
  assert_that(inherits(shape_obj, "sf"))
  assert_that(is.numeric(grid_size))
  assert_that(is.numeric(crs))
  if(!(density_type %in% c("random","gradient","uniform"))){stop("Density_type argument must be 'random', 'gradient', or 'uniform'.")}

  # function
  shape_obj <- shape_obj %>%
    st_transform(crs = crs)
  
  xlim <- bbox(as_Spatial(shape_obj))[1, ]
  ylim <- bbox(as_Spatial(shape_obj))[2, ]
  
  
  region_obj <- make.region(region.name = "Study site",
                            shape = shape_obj,
                            units = "m")
  
  if(density_type == "uniform"){ 
    
    density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
    
  }
  
  
  if(density_type == "gradient"){
    
    assert_that(is.character(gradient_direction))
    if(!(gradient_direction %in% c("N", "NE","E","SE","S","SW","W","NW","C"))){stop("Gradient_direction argument must be 'N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' or 'C'.")}
    assert_that(is.numeric(amplitude))
    assert_that(is.numeric(wavelength))

    
    if(gradient_direction == "N") {          
      x <- mean(xlim)  
      y <- max(ylim)
    }
    if(gradient_direction == "NE") {
      x <- max(xlim)  
      y <- max(ylim)
    }
    
    if(gradient_direction == "E"){
      x <- max(xlim) 
      y <- mean(ylim)
    }
    
    if(gradient_direction == "SE"){
      x <- max(xlim) 
      y <- min(ylim)
    }
    
    if(gradient_direction == "S") {
      x <- mean(xlim)  
      y <- min(ylim)
    }
    
    if(gradient_direction == "SW"){
      x <- min(xlim)  
      y <- min(ylim)
    }
    
    if(gradient_direction == "W"){
      x <- min(xlim)
      y <- mean(ylim) 
    }
    
    if(gradient_direction == "NW"){
      x <- min(xlim)
      y <- max(ylim)
    }
    
    if(gradient_direction == "C"){
      x <- mean(xlim)
      y <- mean(ylim)
    }
    
    density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
    
    density_obj <- add.hotspot(object = density_obj,
                               centre = c(x, y),
                               sigma = wavelength,
                               amplitude = amplitude)
    
  }
  

    if(density_type == "random"){

    assert_that(is.numeric(amplitude))
    assert_that(is.numeric(wavelength))
    assert_that(is.numeric(nb_hotspots))
    
      
          density_obj <- make.density(region = region_obj,
                                x.space = grid_size,
                                y.space = grid_size,
                                constant = 1)
          
          for(i in 1:nb_hotspots){
            
            sigma_n <- runif(1, 1, wavelength)
            amplitude_n <- runif(1, 1, amplitude)
            
            x <- runif(1, xlim[1], xlim[2])
            y <- runif(1, ylim[1], ylim[2])
            
            point <- st_sfc(st_point(c(x,y)), crs = crs)
            a <- as.numeric(st_contains(shape_obj, point))
            
            while(is.na(a==1)){
              
              x <- runif(1, xlim[1], xlim[2])
              y <- runif(1, ylim[1], ylim[2])
              
              point <- st_sfc(st_point(c(x,y)), crs = crs)
              
              a <- as.numeric(st_contains(shape_obj, point))
            }
            
            density_obj <- add.hotspot(object = density_obj,
                                       centre = c(x, y),
                                       sigma = sigma_n,
                                       amplitude = amplitude_n)
            
            rm(a, x, y, sigma_n, amplitude_n)
            
          }
    }
      

    
  # if(density_type == "covariate") {
  #   
  #   density_obj <- make.density(region = region_obj,
  #                               x.space = grid_size,
  #                               y.space = grid_size,
  #                               constant = 1)
  # }
  
  
  map_obj <- density_obj@density.surface %>%
    as.data.frame() %>%
    st_sf(crs = crs) %>%
    mutate(area = st_area(.)) %>%
    mutate(area_grid = grid_size^2) %>%
    drop_units() %>%
    filter(area == area_grid) %>%
    select(density, geometry)
  
}

