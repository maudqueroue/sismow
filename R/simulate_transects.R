# Generated by fusen: do not edit by hand


#' Simulate Transects
#'
#' @description
#' `simulate_transects` allows to simulate transects with different designs and total length. It also allows to segmentize the simulated transects.
#
#' @details
#' This function use create the `make.design` function of the `dssd` package.
#'
#' If segmentize is `TRUE`, `seg_ID` is noted "1-2" for transect 1 segment 2. If segmentize is `FALSE`, `seg_ID` is identical to the transect number (first column).
#'
#' @param shape_obj sf object. The shape of the study site or a density grid.
#' @param design character. Variable describing the type of design. Either `random`, `systematic` (parallel), `eszigzag` (equal-spaced zigzag), `eszigzagcom` (equal spaced crossed zigzag). See `dssd` package for more information.
#' @param design.angle numeric. Value detailing the angle of the design. A value of -1 will cause a random design angle to be generated. See `dssd` package for more information. By default: 0.
#' @param line.length numeric. The approximative total line length desired in m.
#' @param segmentize boolean. If `TRUE` transects are segmentized and a `seg_ID` is given to each segment. If `FALSE`transects are not segmentized. By default: `FALSE`.
#' @param length_segs numeric. Length of the segments desired for segmentation.
#' @param crs numeric. Projection system. By default: 2154.
#' @param ... All other arguments that could be used in the make.design function. See dssd package for more information.
#'
#' @importFrom dssd make.design generate.transects
#' @importFrom sf st_cast st_sf st_geometry st_multilinestring st_sfc st_coordinates st_set_geometry st_crs st_geometry_type st_segmentize st_length st_union st_intersection
#' @importFrom dplyr select mutate
#' @importFrom assertthat assert_that
#' @importFrom units set_units
#'
#' @return The simulated transects corresponding to the differents conditions in a sf dataframe. The dataframe contains four columns: `transect` number, `seg_ID` (a unique identifiant for each segments/transect), `effort` (length of each segment/transect) and `geometry`.
#' @export

#' @examples
#' 
#' library(ggplot2)
#' data("shape_courseulles")
#' 
#' # ------------------------------
#' # Example 1 : parallel transects with a approximative total length of 400000m
#' # ------------------------------
#' 
#' transects <- simulate_transects(shape_obj = shape_courseulles,
#'                              design = "systematic",
#'                              line.length = 400000)
#' # Plot
#' ggplot() +
#'       geom_sf(data = shape_courseulles, fill = "#EDEDE9") +
#'       geom_sf(data = transects) +
#'       theme(panel.background = element_rect(fill = "white"),
#'       panel.grid.major = element_line(colour = "#EDEDE9"))
#' 
#' # ------------------------------
#' # Example 2 : zigzag transects with a approximative total length of 400000m 
#' # that are segmentized with a length of approximately 2000m per segment
#' # ------------------------------
#' 
#' transects <- simulate_transects(shape_obj = shape_courseulles,
#'                              design = "eszigzag",
#'                              line.length = 400000,
#'                              design.angle = 90,
#'                              segmentize = TRUE,
#'                              length_segs = 2000)
#' 
#' # Plot
#' pal <- rep(c("#98C1D9","#EE6C4D","#293241"),nrow(transects)) 
#' ggplot() +
#'       geom_sf(data = shape_courseulles, fill = "#EDEDE9") +
#'       geom_sf(data = transects, aes(colour = seg_ID))+
#'       scale_colour_manual(values=pal) +
#'       theme(legend.position = "none",
#'       panel.background = element_rect(fill = "white"),
#'       panel.grid.major = element_line(colour = "#EDEDE9"))
#' 
#' 
#' # ------------------------------
#' # Example 3 : systematic parallel transects with a approximative total length of 400000m
#' # that are segmentized with a length of approximately 2000m per segment 
#' # the `shape_obj` is a density map simulated with `simulate_density`
#' #-------------------------------
#' 
#' # Create map 
#' map <- simulate_density(shape_obj = shape_courseulles,
#'                               grid_size = 1000,
#'                               density_type = "gradient",
#'                               gradient_direction = "N",
#'                               wavelength = 20000,
#'                               amplitude = 500)
#' 
#' # Create transects
#' transects <- simulate_transects(shape_obj = map,
#'                              design = "systematic",
#'                              line.length = 400000,
#'                              design.angle = 2,
#'                              segmentize = TRUE,
#'                              length_segs = 2000)
#' 
#' # Plot
#' pal <- rep(c("#98C1D9","#EE6C4D","#293241"),nrow(transects)) 
#' ggplot() +
#'       geom_sf(data = map, color = "#D9D9D9") +
#'       geom_sf(data = transects, aes(colour = seg_ID))+
#'       scale_colour_manual(values = pal) +
#'       theme(legend.position = "none",
#'       panel.background = element_rect(fill = "white"),
#'       panel.grid.major = element_line(colour = "#EDEDE9"))
#' 
simulate_transects <- function(shape_obj, design = "systematic", design.angle = 0, line.length, segmentize = FALSE, length_segs, crs = 2154, ...) {
  
  # Function checks
  assert_that(inherits(shape_obj, "sf"))
  assert_that(is.numeric(crs))
  assert_that(is.numeric(line.length))
  assert_that(is.numeric(design.angle))
    if(!(design %in% c("random","systematic","eszigzag","eszigzagcom"))){stop("Design argument must be 'random', 'systematic', 'eszigzag' or 'eszigzagcom'.")}


  # Function
  shape_obj <- shape_obj %>%
    st_transform(crs = crs) %>%
    st_union()
  
  
  region_obj <- make.region(region.name = "Study site",
                            shape = shape_obj,
                            units = "m")
  
  transect.design <- make.design(region = region_obj,
                                 design = design,
                                 design.angle = design.angle,
                                 line.length = line.length,
                                 ...)
  
  transect.survey <- generate.transects(transect.design)
  
  x <- transect.survey@samplers %>%
    as.data.frame() %>%
    select("transect","geometry") %>%
    st_sf(crs = crs) #%>%
    #st_cast("LINESTRING")
  
if(segmentize == TRUE){
  
  ### Segmentize
  #-----------------
  assert_that(is.numeric(length_segs))
  
  transect_obj <- st_segmentize(x, dfMaxLength = set_units(length_segs, "metres"))
  # geometry
  ggg <- st_geometry(transect_obj)
  
  # check
  if (isFALSE(st_geometry_type(ggg) %in% c("LINESTRING"))) {
    stop("Input should be LINESTRING")
  }
  
  # loop to segmentize
  for (k in 1:length(st_geometry(ggg))) {
    # segment in each transect as sf multilinestring
    sub <- ggg[k]
    geom <- lapply(1:(length(st_coordinates(sub)[, 1]) - 1),
      function(i)rbind(as.numeric(st_coordinates(sub)[i, 1:2]), as.numeric(st_coordinates(sub)[i + 1, 1:2]))) %>%
      st_multilinestring() %>%
      st_sfc()
    # create endgeom with the multilinestring for each transect
    if (k == 1) {endgeom <- geom}
    else {endgeom <- rbind(endgeom, geom)}
  }
  
  # sf object
  endgeom <- endgeom %>% 
    st_sfc(crs = crs) 

  # Multilinestring to linestring
  endgeom <- st_set_geometry(transect_obj, endgeom) %>% 
    st_cast("LINESTRING") 
  
  ### Add effort
  #----------------
  endgeom$effort <- st_length(endgeom)
  
  ### Name segment
  #-----------------
  endgeom$seg_ID <- NA
  # loop over the transect IDs
  for(this_transect in unique(endgeom$transect)){
    # how many segments in this transect?
    n_segs <- nrow(subset(endgeom, transect==this_transect))
    # generate the n_segs labels that we need
    endgeom$seg_ID[endgeom$transect==this_transect] <- paste(this_transect, 1:n_segs, sep="-")}
  
  x <- endgeom
  }
  
  if(segmentize == FALSE){
    x <- x %>% 
      mutate(seg_ID = transect) %>%
      mutate(effort = st_length(.))
  }
  
  x <- x %>%
    st_intersection(shape_obj) %>%
    select(transect, seg_ID, effort, geometry)
  
  return(x)
}

