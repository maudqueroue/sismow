# Generated by fusen: do not edit by hand


#' esw_hn
#'
#' @param sigma numeric. Sigma of half normal function.
#'
#' @importFrom stats pnorm dnorm
#' @importFrom assertthat assert_that
#'
#' @return numeric. esw value associated to the sigma given.
#' @keywords internal
#' @export

esw_hn <- function(sigma){
  
  assert_that(is.numeric(sigma))
  
  esw <- (pnorm(+Inf, 0, sigma) - 0.5) / dnorm(0, 0, sigma)
  return(esw)
  
  }



#' Scale hn
#'
#' @param esw numeric. Effective strip width.
#' @param lower numeric. Lower range of search.
#' @param upper numeric. Upper range of search.
#'
#' @importFrom stats uniroot
#' @importFrom assertthat assert_that
#'
#' @return numeric. The sigma parameter of a half normal function associated with a esw value.
#' @keywords internal
#' @export


scale_hn <- function(esw, lower = 1e-3, upper = 5) {
  
  assert_that(is.numeric(esw))
  res <- as.numeric(uniroot(function(x, ...) {esw_hn(sigma = x) - esw},
                            lower = lower,
                            upper = upper,
                            tol = 1e-8)[1])
  return(res)
}



#' Simulate observation
#'
#' @description
#' `simulate_obs` allows to simulate to simulate dataset of observations according to individuals simulated on the density map, a transect design a detection probability 
#
#' @details
#' To calculate the detection probability, the function calculate first the distance between the individual/group and the nearest transect.
#'
#' @param ind_obj dataframe. Individuals simulated with their coordinates.
#' @param transect_obj sf dataframe. Transect/segments data.
#' @param key character. Form of the detection function "hn" or "unif".
#' @param esw numeric. Effective strip width in m. This argument is needed only for the 'hn' form.
#' @param g_zero numeric. The detection probability at distance 0. By default 1.
#' @param truncation numeric. A single numeric value in m describing the longest distance at which an object may be observed. By default = NA.
#' @param crs numeric. Projection system. By default = 2154.
#'
#' @importFrom dplyr mutate rename n
#' @importFrom stats rbinom
#' @importFrom units drop_units
#' @importFrom sf st_as_sf st_nearest_feature st_distance st_drop_geometry
#' @importFrom assertthat assert_that
#'
#' @return dataframe. The dataframe contains all the individuals/groups of the map. The dataframe contains the identification of individuals/groups, their size, if their are detected, their probability of detection, the identification of nearest transect/segment and their localisation. 
#' @export


#' @examples
#' 
#' library(ggplot2)
#' data("shape_courseulles")
#' 
#' # First, create a density map
#' map <- simulate_density(shape_obj = shape_courseulles,
#'                         density_type = "gradient",
#'                         gradient_direction = "N",
#'                         wavelength = 20000,
#'                         amplitude = 500)
#' 
#' # Then simulate the presence of individuals in the study area 
#' ind <- simulate_ind(map_obj = map, N = 500)
#' 
#' # Then create transects
#' transects <- simulate_transects(shape_obj = map,
#'                                 design = "systematic",
#'                                 line.length = 400000,
#'                                 design.angle = 2,
#'                                 segmentize = TRUE,
#'                                 length_segs = 2000)
#' 
#' # Finally, detection of individuals simulated on the map 
#' # according to simulated densities and simulated transects :
#' 
#' # ------------------------------
#' # Example 1 : With a half normal detection probability equal to 1 at 0 distance (g_zero)
#' # with a effective half width of 180 m.
#' # ------------------------------
#' 
#' obs <- simulate_obs(ind_obj = ind,
#'                     transect_obj = transects,
#'                     key = "hn",
#'                     g_zero = 1,
#'                     esw = 180)
#' 
#' # Plot detection probability
#' ggplot(obs, aes(x=distance, y=proba)) +
#'   geom_point(color = "#EE6C4D") +
#'   xlim(0,500) 
#' 
#' # Plot on map
#' ggplot() +
#'   geom_sf(data = map, fill = "#CDDAFD", color = "#CDDAFD") +
#'   geom_sf(data = transects, color = "black") +
#'   geom_point(data=obs[obs$detected==0,], aes(x=x, y=y), shape=20, color="#051923") +
#'   geom_point(data=obs[obs$detected==1,], aes(x=x, y=y), shape=21, fill="#EE6C4D") +
#'   labs(caption = paste("Sightings = ", sum(obs$detected), sep = " ")) +
#'   theme(legend.position = "none",
#'         panel.background = element_rect(fill = "white"),
#'         panel.grid.major = element_line(colour = "#EDEDE9"))
#' 
#' 
#' # ------------------------------
#' # Example 2 : With a uniforme detection probability equal to 1 below distance 200 m.
#' # ------------------------------
#' 
#' obs <- simulate_obs(ind_obj = ind,
#'                     transect_obj = transects,
#'                     key = "unif",
#'                     g_zero = 1,
#'                     truncation = 200)
#' 
#' # Plot detection probability
#' ggplot(obs, aes(x=distance, y=proba)) +
#'   geom_point(color = "#EE6C4D") +
#'   xlim(0,500) 
#' 
#' # Plot on map
#' ggplot() +
#'   geom_sf(data = map, fill = "#CDDAFD", color = "#CDDAFD") +
#'   geom_sf(data = transects, color = "black") +
#'   geom_point(data=obs[obs$detected==0,], aes(x=x, y=y), shape=20, color="#051923") +
#'   geom_point(data=obs[obs$detected==1,], aes(x=x, y=y), shape=21, fill="#EE6C4D") +
#'   labs(caption = paste("Sightings = ", sum(obs$detected), sep = " ")) +
#'   theme(legend.position = "none",
#'         panel.background = element_rect(fill = "white"),
#'         panel.grid.major = element_line(colour = "#EDEDE9"))
#' 
simulate_obs <- function(ind_obj, transect_obj, key, esw = NA, g_zero = 1, truncation = NA, crs = 2154) {
  
  # Function checks
  
   assert_that(inherits(ind_obj, "data.frame"))
  if (!all(c("x", "y") %in% names(ind_obj))) {stop("ind_obj must contain `x` and `y` coordinates columns. Verify your column names.")}
  assert_that(is.numeric(g_zero))
  assert_that(inherits(transect_obj, "sf"))
  assert_that(is.numeric(crs))
  if(!(key %in% c("unif", "hn"))){stop("Key argument must be `unif` or `hn`.")}
  
  # Function
  
  # Calculate distance between individuals and nearest transect/segment
  
  # obs point in sf format
  dsf <- ind_obj %>%
    select("x","y") %>%
    st_as_sf(coords = c("x","y"), crs = crs)
  
  # Calculate the closest transect/segment
  nearest_spee <- st_nearest_feature(x = dsf, y = transect_obj)
  
  # Calculate distance between point and transect
  dist_obj <- st_distance(dsf, transect_obj[nearest_spee,], by_element = TRUE)
  
  transect_obj <- transect_obj %>%
    st_drop_geometry()
  
  # summary table
  dist_obj <- dist_obj %>%
    as.data.frame() %>%
    rename(distance = '.') %>%
    mutate(seg_ID = transect_obj[nearest_spee,'seg_ID'],
           size = ind_obj$size,
           distance_km = distance / 1e3,
           x = ind_obj$x,
           y = ind_obj$y,
           object_ID = 1:n()) %>%
    drop_units()
  
  if(key == 'hn'){
    
    if(is.numeric(esw)==FALSE) {stop("With 'hn' key, esw must have a numeric value")}
    
    esw_km <- esw / 1000
    sigma <- scale_hn(esw = esw_km)
    dist_obj <- dist_obj %>%
      mutate(proba = exp(-(distance_km)^2 / (2 * sigma * sigma))*g_zero) %>%
      mutate(detected = rbinom(nrow(dist_obj), size = 1, prob = proba))
    
    if(is.na(truncation) == FALSE){
      dist_obj$detected[dist_obj$distance > truncation] <- 0
    }
    
  }
  
  if(key == 'unif'){
    
    if(is.numeric(truncation)==FALSE) {stop("With 'unif' key, truncation must have a numeric value")}

    dist_obj <- dist_obj %>%
      mutate(proba = g_zero) %>%
      mutate(detected = rbinom(nrow(dist_obj), size = 1, prob = proba))
    
    dist_obj$detected[dist_obj$distance > truncation] <- 0
    dist_obj$proba[dist_obj$distance > truncation] <- 0
  }
  
  
  dist_obj <- dist_obj %>%
    select(object_ID, size, detected, proba, distance, seg_ID, x, y)
  
  return(dist_obj)
  
}
